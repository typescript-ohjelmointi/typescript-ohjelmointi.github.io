"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[703],{7367:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var i=t(5893),a=t(1151);const o={sidebar_position:2},s="Type ja interface",r={id:"tyypit/type-ja-interface",title:"Type ja interface",description:"https://www.typescriptlang.org/docs/handbook/interfaces.html",source:"@site/docs/tyypit/02-type-ja-interface.md",sourceDirName:"tyypit",slug:"/tyypit/type-ja-interface",permalink:"/docs/tyypit/type-ja-interface",draft:!1,unlisted:!1,editUrl:"https://github.com/typescript-ohjelmointi/typescript-ohjelmointi.github.io/tree/main/docs/tyypit/02-type-ja-interface.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Perustietotyypit",permalink:"/docs/tyypit/tyyppijarjestelma"},next:{title:"JavaScript-koodin tyyppim\xe4\xe4rittelyt",permalink:"/docs/tyypit/typing-js-code"}},l={},d=[{value:"Union (<code>number | string</code>)",id:"union-number--string",level:3},{value:"Intersection (<code>&amp;</code>)",id:"intersection-",level:3},{value:"Tuplet (monikko)",id:"tuplet-monikko",level:3},{value:"Muita kiinnostavia ominaisuuksia",id:"muita-kiinnostavia-ominaisuuksia",level:3},{value:"Structural typing:",id:"structural-typing",level:2},{value:"Literals and narrowing down to narrowest type:",id:"literals-and-narrowing-down-to-narrowest-type",level:2},{value:"Using control flow analysis (CFA) to narrow down the type with following the JavaScript logic.",id:"using-control-flow-analysis-cfa-to-narrow-down-the-type-with-following-the-javascript-logic",level:2},{value:"Another example of (nested) CFA https://retool.com/blog/typescript-control-flow-analysis-best-of/",id:"another-example-of-nested-cfa-httpsretoolcomblogtypescript-control-flow-analysis-best-of",level:2},{value:"Conditional types + extends keyword",id:"conditional-types--extends-keyword",level:2},{value:"Bonus: still some peculiarities about narrowing",id:"bonus-still-some-peculiarities-about-narrowing",level:2},{value:"Bonus: Some confusing examples of Accessing type of a property",id:"bonus-some-confusing-examples-of-accessing-type-of-a-property",level:2},{value:"Bonus: Additional advanced features like the &quot;infer&quot; keyword are left for self study..",id:"bonus-additional-advanced-features-like-the-infer-keyword-are-left-for-self-study",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"type-ja-interface",children:"Type ja interface"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.typescriptlang.org/docs/handbook/interfaces.html",children:"https://www.typescriptlang.org/docs/handbook/interfaces.html"})}),"\n",(0,i.jsx)(n.p,{children:'TypeScriptist\xe4 on merkitt\xe4v\xe4\xe4 hy\xf6ty\xe4 silloin, kun omassa ohjelmalogiikassa hy\xf6dynnet\xe4\xe4n eri tyyppisi\xe4 olioita. Yksinkertaisimmillaan "oliotyyppi" voidaan m\xe4\xe4ritell\xe4 suoraan muuttujaan:'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"let user: { id: number, name: string } = { id: 1, name: 'Alice'};\n"})}),"\n",(0,i.jsx)(n.p,{children:'Tyypin m\xe4\xe4ritteleminen muuttujaan on kuitenkin usein erityisesti uudelleenk\xe4ytett\xe4vyyden n\xe4k\xf6kulmasta huono idea. Tyypeille voidaankin m\xe4\xe4ritell\xe4 "aliaksia", jotka tekev\xe4t niist\xe4 uudelleenk\xe4ytett\xe4vi\xe4:'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"type User = {\n    id: number;\n    name: string;\n};\n\nlet user1: User = { id: 1, name: 'Alice' };\nlet user2: User = { id: 2, name: 'Bob' };\n"})}),"\n",(0,i.jsx)(n.p,{children:"Eri tyypeiss\xe4 voi olla my\xf6s valinnaisia attribuutteja:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"type User = {\n    id: number;\n    name: string;\n    email?: string;  // `?` tarkoittaa valinnaista arvoa\n};\n\nlet user1: User = { id: 1, name: 'Alice' };\nlet user2: User = { id: 2, name: 'Bob', email: 'bob@example.com' };\n\nconsole.log(user2.email.toLowerCase());   // k\xe4\xe4nn\xf6svirhe, koska email saattaa olla `undefined`\nconsole.log(user2.email?.toLowerCase());  // JS:n \"optional chaining\" -> ei virhett\xe4\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"union-number--string",children:["Union (",(0,i.jsx)(n.code,{children:"number | string"}),")"]}),"\n",(0,i.jsx)(n.p,{children:"Uusia tyyppej\xe4 voidaan my\xf6s luoda yhdistelem\xe4ll\xe4 vakioita tai olemassa olevia tyyppej\xe4:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"type Size = 's' | 'm' | 'l'; // sallii vain n\xe4m\xe4 ennalta m\xe4\xe4r\xe4tyt merkkijonot\n\ntype Shirt = {\n    size: Size;\n}\n\nlet smallShirt = { size: 's' }; // ok\n\nlet unknownShirt = { size: 'tall' }; // k\xe4\xe4nn\xf6svirhe!\n"})}),"\n",(0,i.jsx)(n.p,{children:"Yleinen k\xe4ytt\xf6tapaus union-tyypeille on my\xf6s esimerkiksi joko numeron tai merkkijonon salliminen parametrina:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types\nfunction printId(id: number | string) {\n  console.log("Your ID is: " + id);\n}\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"intersection-",children:["Intersection (",(0,i.jsx)(n.code,{children:"&"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["Uusia tyyppej\xe4 voidaan my\xf6s yhdistell\xe4 olemassa olevista tyypeist\xe4 ",(0,i.jsx)(n.em,{children:"intersection"})," -operaatiolla. Seuraavassa esimerkiss\xe4 on m\xe4\xe4ritetty tyypit ",(0,i.jsx)(n.code,{children:"Coordinate"})," ja ",(0,i.jsx)(n.code,{children:"Address"}),", sek\xe4 ",(0,i.jsx)(n.code,{children:"MapMarker"}),", joka sis\xe4lt\xe4\xe4 molempien edell\xe4 mainittujen tyyppien attribuutit:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"type Coordinate = {\n    lat: number;\n    lon: number;\n};\n\ntype Address = {\n    street: string;\n    city: string;\n};\n\ntype MapMarker = Address & Coordinate;\n\nlet haagaHelia: MapMarker = {\n    lat: 60,\n    lon: 24,\n    street: 'Ratapihantie 13',\n    city: 'Helsinki'\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Eri tyyppien yhdist\xe4minen voi olla k\xe4tev\xe4\xe4 esimerkiksi tapauksissa, joissa k\xe4ytt\xe4isit perint\xe4\xe4. Esimerkiksi tietokannasta luettujen tietojen yhteiset osat ",(0,i.jsx)(n.code,{children:"id"}),", ",(0,i.jsx)(n.code,{children:"createdAt"})," ja ",(0,i.jsx)(n.code,{children:"updatedAt"})," voidaan sis\xe4llytt\xe4\xe4 muihin tyyppeihi, kuten ",(0,i.jsx)(n.code,{children:"Author"})," ja ",(0,i.jsx)(n.code,{children:"Book"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"type Entity = {\n    id: number;\n    createdAt: Date;\n    updatedAt: Date;\n    deletedAt?: Date;\n};\n\ntype Author = Entity & { name: string };\ntype Book = Entity & { title: string, author: Author };\n"})}),"\n",(0,i.jsx)(n.h3,{id:"tuplet-monikko",children:"Tuplet (monikko)"}),"\n",(0,i.jsxs)(n.p,{children:["TS tukee JavaScriptin taulukoille my\xf6s erityist\xe4 ",(0,i.jsx)(n.a,{href:"https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types",children:"tuple-tyyppi\xe4"}),", jossa voidaan ennalta m\xe4\xe4ritell\xe4 taulukon pituus ja kunkin eri indeksin tyyppi:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"type NameAndAge = [string, number];\n\nlet alice: NameAndAge = ['Alice', 29];  // ok!\nlet bob: NameAndAge = ['Bob', 28, 1];   // k\xe4\xe4nn\xf6svirhe! `Source has 3 element(s) but target allows only 2`\n"})}),"\n",(0,i.jsx)(n.h3,{id:"muita-kiinnostavia-ominaisuuksia",children:"Muita kiinnostavia ominaisuuksia"}),"\n",(0,i.jsxs)(n.p,{children:["TypeScript mahdollistaa useita erilaisia k\xe4tevi\xe4 tapoja edist\xe4\xe4 oman koodin yll\xe4pidett\xe4vyytt\xe4, kuten ",(0,i.jsx)(n.code,{children:"private"})," ja ",(0,i.jsx)(n.code,{children:"readonly"})," -attribuutit sek\xe4 ",(0,i.jsx)(n.code,{children:"as const"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const days = ['ma', 'ti', 'ke', 'to', 'pe', 'la', 'su'] as const;\ndays[0] = 'm\xe5ndag'; // error: \"Index signature in type 'readonly string[]' only permits reading.\"\n"})}),"\n",(0,i.jsxs)(n.p,{children:["JavaScriptin ",(0,i.jsx)(n.code,{children:"const"})," varmistaa, ett\xe4 muuttujaan ei voida asettaa uutta arvoa. ",(0,i.jsx)(n.code,{children:"const"}),"-muuttujaan asetetun arvon muuttaminen on kuitenkin mahdollista, esimerkiksi lis\xe4\xe4m\xe4ll\xe4 listaan uusia arvoja. TypeScriptin ",(0,i.jsx)(n.code,{children:"as const"})," varmistaa muuttujan lis\xe4ksi my\xf6s siihen asetetun arvon muuttumattomuuden. N\xe4ihin ominaisuuksiin voit perehty\xe4 lis\xe4\xe4 itsen\xe4isesti."]}),"\n",(0,i.jsx)(n.h2,{id:"structural-typing",children:"Structural typing:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"class Foo {\n  x: number = 0;\n}\nclass Blaa {\n  x: number = 0;\n}\nlet f: Foo = new Blaa();\nlet b: Blaa = new Foo();\n\nconst c = b as Foo;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"literals-and-narrowing-down-to-narrowest-type",children:"Literals and narrowing down to narrowest type:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'let limitToOnlyHello = "Hello" as const;\nlimitToOnlyHello = "World"; //error, only Hello allowed\n'})}),"\n",(0,i.jsx)(n.h2,{id:"using-control-flow-analysis-cfa-to-narrow-down-the-type-with-following-the-javascript-logic",children:"Using control flow analysis (CFA) to narrow down the type with following the JavaScript logic."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'const square = (x: number | undefined) => {\n  if (!x) {\n    throw "Undefined";\n  }\n  return x * x;\n};\nconst square2 = (x: number | undefined) => {\n  if (typeof x !== "number") {\n    //typeof type guard\n    throw "Not a number";\n  }\n  return x * x;\n};\nconst square3 = (x: number | undefined | string) => {\n  if (typeof x === "string") {\n    //typeof type guard\n    throw "Not a number";\n  } else if (!x) {\n    throw "Undefined";\n  }\n  return x * x;\n};\nconst square4 = (x: number | Date) => {\n  if (x instanceof Date) {\n    //Date is a class that can be initialized\n    throw "Invalid type";\n  }\n  if (typeof x === "Date") {\n    //Error: This comparison appears to be unintentional because the types \'"string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"\' and \'"Date"\' have no overlap.\n    throw "Invalid type";\n  }\n  return x * x;\n};\n'})}),"\n",(0,i.jsxs)(n.h2,{id:"another-example-of-nested-cfa-httpsretoolcomblogtypescript-control-flow-analysis-best-of",children:["Another example of (nested) CFA ",(0,i.jsx)(n.a,{href:"https://retool.com/blog/typescript-control-flow-analysis-best-of/",children:"https://retool.com/blog/typescript-control-flow-analysis-best-of/"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'const doSomething = (x: string | number | boolean) => {\n  const isString = typeof x === "string";\n  const isNumber = typeof x === "number";\n  const isStringOrNumber = isString || isNumber;\n\n  if (isStringOrNumber) {\n    x; // string | number\n    if (typeof x === "number") {\n      x; //number\n    }\n  } else {\n    x; //boolean\n  }\n};\n'})}),"\n",(0,i.jsx)(n.h2,{id:"conditional-types--extends-keyword",children:"Conditional types + extends keyword"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'//"T extends string", T=string\n//In addition need to utilise a conditional deduction logic with the types (with ternary ? : -syntax).\ntype DerivedType = typeof c extends Foo ? Foo : Blaa;\n'})}),"\n",(0,i.jsx)(n.h2,{id:"bonus-still-some-peculiarities-about-narrowing",children:"Bonus: still some peculiarities about narrowing"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.typescriptlang.org/docs/handbook/2/narrowing.html",children:"https://www.typescriptlang.org/docs/handbook/2/narrowing.html"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'//JavaScript has an operator for determining if an object has a property with a name: the in operator.\n//TypeScript takes this into account as a way to narrow down potential types.\ntype Fish = { swim: () => void };\ntype Bird = { fly: () => void };\ntype Human = { swim?: () => void; fly?: () => void };\ntype Animal = Fish | Bird | Human;\nfunction move(animal: Animal) {\n  if ("swim" in animal) {\n    //Narrow down the type with JavaScript in operator\n    animal; //animal narrowed to Fish | Human\n    if ("fly" in animal) {\n      animal; //animal narrowed to Human\n    } else {\n      animal; //here it\'s still a Fish or Human, because TypeScript uses a concept called "control flow based type analysis" to determine the types of variables. This means that TypeScript can infer the type of a variable based on the control flow of the program, but it doesn\'t keep track of the types of variables within the different branches of the control flow. So, even though the type of animal was narrowed to Human in the previous block, TypeScript doesn\'t know that the type of animal is not Fish in the surrounding if-else block.\n    }\n  } else {\n    animal; //animal narrowed to Bird | Human\n  }\n  if (animal instanceof Fish) {\n    //The instanceof operator is used to check the constructor of an object, but it doesn\'t work with discriminated unions. instanceof works by checking the prototype chain of an object, but since a union type can have multiple different prototypes, it can\'t determine the type correctly.\n    animal;\n  }\n}\n\ntype Foo3 = {\n  x: number;\n};\ntype NumberType = Foo3["x"];\n'})}),"\n",(0,i.jsx)(n.h2,{id:"bonus-some-confusing-examples-of-accessing-type-of-a-property",children:"Bonus: Some confusing examples of Accessing type of a property"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'const x = new Foo().x;\ntype FooType = {\n  x: number;\n};\ntype XConst = typeof x;\ntype X = Foo["x"];\ntype XType = FooType["x"];\n'})}),"\n",(0,i.jsx)(n.h2,{id:"bonus-additional-advanced-features-like-the-infer-keyword-are-left-for-self-study",children:'Bonus: Additional advanced features like the "infer" keyword are left for self study..'})]})}function p(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>s});var i=t(7294);const a={},o=i.createContext(a);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);