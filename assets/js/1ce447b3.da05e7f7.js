"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8367],{4802:(i,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>r,toc:()=>d});var t=n(5893),a=n(1151);const s={sidebar_position:6},o="Tyyppien unionit ja leikkaukset",r={id:"tyypit/unions-intersections",title:"Tyyppien unionit ja leikkaukset",description:"TypeScriptiss\xe4 eri tyyppej\xe4 voidaan ilmaista joukko-opin termien mukaisesti unioneilla (union) ja leikkauksilla (intersection). Unionin tapauksessa tyyppi k\xe4sitt\xe4\xe4 ik\xe4\xe4n kuin vaihtehtoisia toisistaan erillisi\xe4 tyyppej\xe4. Leikkaus puolestaan m\xe4\xe4rittelee tyypin, joka t\xe4ytt\xe4\xe4 molempien siihen kuuluvien tyyppien piirteet.",source:"@site/docs/tyypit/05-unions-intersections.md",sourceDirName:"tyypit",slug:"/tyypit/unions-intersections",permalink:"/docs/tyypit/unions-intersections",draft:!1,unlisted:!1,editUrl:"https://github.com/typescript-ohjelmointi/typescript-ohjelmointi.github.io/tree/main/docs/tyypit/05-unions-intersections.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Geneeriset tyypit",permalink:"/docs/tyypit/generics"},next:{title:"Map-tyypit (mapped types)",permalink:"/docs/tyypit/mapped-types"}},l={},d=[{value:"Unionit (<code>a | b</code>)",id:"unionit-a--b",level:2},{value:"Leikkaukset (<code>a &amp; b</code>)",id:"leikkaukset-a--b",level:2},{value:"Leikkaukset ja unionit taulukoissa",id:"leikkaukset-ja-unionit-taulukoissa",level:2},{value:"Pohdittavaa",id:"pohdittavaa",level:3},{value:"Control flow analysis (CFA)",id:"control-flow-analysis-cfa",level:2},{value:"Sis\xe4kk\xe4inen Control flow analysis -esimerkki",id:"sis\xe4kk\xe4inen-control-flow-analysis--esimerkki",level:3},{value:"Bonus: lis\xe4\xe4 yksityiskohtia tyyppien rajauksesta",id:"bonus-lis\xe4\xe4-yksityiskohtia-tyyppien-rajauksesta",level:2},{value:"Discriminated unions",id:"discriminated-unions",level:2}];function p(i){const e={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,a.a)(),...i.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h1,{id:"tyyppien-unionit-ja-leikkaukset",children:"Tyyppien unionit ja leikkaukset"}),"\n",(0,t.jsx)(e.p,{children:"TypeScriptiss\xe4 eri tyyppej\xe4 voidaan ilmaista joukko-opin termien mukaisesti unioneilla (union) ja leikkauksilla (intersection). Unionin tapauksessa tyyppi k\xe4sitt\xe4\xe4 ik\xe4\xe4n kuin vaihtehtoisia toisistaan erillisi\xe4 tyyppej\xe4. Leikkaus puolestaan m\xe4\xe4rittelee tyypin, joka t\xe4ytt\xe4\xe4 molempien siihen kuuluvien tyyppien piirteet."}),"\n",(0,t.jsxs)(e.h2,{id:"unionit-a--b",children:["Unionit (",(0,t.jsx)(e.code,{children:"a | b"}),")"]}),"\n",(0,t.jsxs)(e.p,{children:["Uusia tyyppej\xe4 voidaan ilmaista yhdistelem\xe4ll\xe4 vakioita tai olemassa olevia tyyppej\xe4. Jos esimerkiksi haluamme luoda tyypin ",(0,t.jsx)(e.code,{children:"Size"}),", joka sallii ainoastaan merkkijonovakiot ",(0,t.jsx)(e.code,{children:"s"}),", ",(0,t.jsx)(e.code,{children:"m"})," ja ",(0,t.jsx)(e.code,{children:"l"}),", voimme luoda sen unionin ",(0,t.jsx)(e.code,{children:"|"})," avulla seuraavasti:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"type Size = 's' | 'm' | 'l'; // sallii vain n\xe4m\xe4 ennalta m\xe4\xe4r\xe4tyt merkkijonot\n"})}),"\n",(0,t.jsxs)(e.p,{children:["T\xe4t\xe4 uutta ",(0,t.jsx)(e.code,{children:"Size"}),"-tyyppi\xe4 voidaan sen j\xe4lkeen k\xe4ytt\xe4\xe4 ohjelmassa kuten mit\xe4 tahansa tyyppi\xe4. TypeScript osaa tarkastaa aina sit\xe4 k\xe4ytett\xe4ess\xe4, ett\xe4 arvo kuuluu ennalta m\xe4\xe4ritettyyn joukkoon:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"type Shirt = {\n    size: Size;\n};\n\nlet smallShirt = { size: 's' }; // ok\n\nlet unknownShirt = { size: 'tall' }; // k\xe4\xe4nn\xf6svirhe!\n"})}),"\n",(0,t.jsx)(e.p,{children:"Mik\xe4li muuttujan tyypiksi m\xe4\xe4ritell\xe4\xe4n unioni, voidaan siihen asettaa arvoja, jotka vastaavat mit\xe4 tahansa unionissa m\xe4\xe4ritetty\xe4 tyyppi\xe4:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"let id: number | string;\n\nid = 100;       // ok\nid = 'a1b2c3';  // ok\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Yleinen k\xe4ytt\xf6tapaus union-tyypeille on eri tyyppisten arvojen salliminen funktion parametrina. Seuraavassa esimerkiss\xe4 ",(0,t.jsx)(e.code,{children:"printId"}),"-funktiota voidaan kutsua joko ",(0,t.jsx)(e.code,{children:"number"}),"- tai ",(0,t.jsx)(e.code,{children:"string"}),"-tyyppisell\xe4 arvolla:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'// https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types\nfunction printId(id: number | string) {\n    console.log("Your ID is: " + id);\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:["Yll\xe4 parametrin tyypiksi on m\xe4\xe4ritetty ",(0,t.jsx)(e.em,{children:"unioni"})," ",(0,t.jsx)(e.code,{children:"number | string"}),", eli funktio sallii kumman tahansa tyyppisen arvon k\xe4ytt\xe4j\xe4n id",":n","\xe4."]}),"\n",(0,t.jsxs)(e.p,{children:["Unioni voidaan m\xe4\xe4ritell\xe4 suoraan muuttujan tai parametrin tyypiksi, mutta monessa tilanteessa voi olla kannattavaa m\xe4\xe4ritell\xe4 uusi ",(0,t.jsx)(e.em,{children:"alias"})," kuten ",(0,t.jsx)(e.code,{children:"UserId"}),". T\xe4m\xe4 edesauttaa koodin luettavuutta ja yll\xe4pidett\xe4vyytt\xe4 erityisesti mik\xe4li samaa unionia tarvitaan lukuisissa kohdissa:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'type UserId = string | number;\n\n// https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types\nfunction printId(id: UserId) {\n    console.log("Your ID is: " + id);\n}\n'})}),"\n",(0,t.jsxs)(e.h2,{id:"leikkaukset-a--b",children:["Leikkaukset (",(0,t.jsx)(e.code,{children:"a & b"}),")"]}),"\n",(0,t.jsxs)(e.p,{children:["Uusia tyyppej\xe4 voidaan my\xf6s yhdistell\xe4 olemassa olevista tyypeist\xe4 ",(0,t.jsx)(e.em,{children:"intersection"})," -operaatiolla. Seuraavassa esimerkiss\xe4 on m\xe4\xe4ritetty tyypit ",(0,t.jsx)(e.code,{children:"Coordinate"})," ja ",(0,t.jsx)(e.code,{children:"Address"}),'. Lis\xe4ksi siin\xe4 on m\xe4\xe4ritetty "karttapistett\xe4" varten tyyppi, joka sis\xe4lt\xe4\xe4 sek\xe4 osoitteen ett\xe4 koordinaatin attribuutit. T\xe4m\xe4 karttapiste on toteutettu ',(0,t.jsx)(e.code,{children:"MapMarker"}),"-nimisen\xe4 ja se sis\xe4lt\xe4\xe4 koordinaatin ja osoitteen unionin ",(0,t.jsx)(e.code,{children:"Address & Coordinate"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"type Coordinate = {\n    lat: number;\n    lon: number;\n};\n\ntype Address = {\n    street: string;\n    city: string;\n};\n\ntype MapMarker = Address & Coordinate;\n\nlet haagaHelia: MapMarker = {\n    lat: 60,\n    lon: 24,\n    street: 'Ratapihantie 13',\n    city: 'Helsinki'\n};\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Yll\xe4 ",(0,t.jsx)(e.code,{children:"haagaHelia"}),"-oliolla on nelj\xe4 muuttujaa, joista kaksi ensimm\xe4ist\xe4 on m\xe4\xe4ritetty ",(0,t.jsx)(e.code,{children:"Coordinate"}),"-tyypiss\xe4 ja kaksi seuraavaa ",(0,t.jsx)(e.code,{children:"Address"}),"-tyypiss\xe4. Koska olio asetetaan muuttujaan, joka on n\xe4iden tyyppien unioni, edellytt\xe4\xe4 TypeScript ett\xe4 siit\xe4 l\xf6ytyy kaikki molempien tyyppien arvot."]}),"\n",(0,t.jsxs)(e.p,{children:['Eri tyyppien yhdist\xe4minen voi olla k\xe4tev\xe4\xe4 esimerkiksi tapauksissa, joissa k\xe4ytt\xe4isit luokkiin perustuvassa tyypityksess\xe4 perint\xe4\xe4. Esimerkiksi tietokannasta luettujen tietojen "tavanomaiset" osat ',(0,t.jsx)(e.code,{children:"id"}),", ",(0,t.jsx)(e.code,{children:"createdAt"})," ja ",(0,t.jsx)(e.code,{children:"updatedAt"})," voidaan sis\xe4llytt\xe4\xe4 muihin tyyppeihi, kuten ",(0,t.jsx)(e.code,{children:"Author"})," ja ",(0,t.jsx)(e.code,{children:"Book"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"type Entity = {\n    id: number;\n    createdAt: Date;\n    updatedAt: Date;\n    deletedAt?: Date;\n};\n\ntype Author = Entity & { name: string };\ntype Book = Entity & { title: string, author: Author };\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Yll\xe4 ",(0,t.jsx)(e.code,{children:"Author"})," sis\xe4lt\xe4\xe4 kaikki ",(0,t.jsx)(e.code,{children:"Entity"}),"-tyypin attribuutit, joiden lis\xe4ksi sill\xe4 on my\xf6s ",(0,t.jsx)(e.code,{children:"name"}),". Vastaavasti ",(0,t.jsx)(e.code,{children:"Book"}),"-tyyppi sis\xe4lt\xe4\xe4 yhteisten attribuuttien lis\xe4ksi nimen ja kirjoittajan."]}),"\n",(0,t.jsxs)(e.p,{children:["Voit lukea aiheesta lis\xe4\xe4 ",(0,t.jsx)(e.a,{href:"https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html",children:"TypeScriptin k\xe4sikirjasta"}),"."]}),"\n",(0,t.jsx)(e.h2,{id:"leikkaukset-ja-unionit-taulukoissa",children:"Leikkaukset ja unionit taulukoissa"}),"\n",(0,t.jsxs)(e.p,{children:["My\xf6s taulukot voivat sis\xe4lt\xe4\xe4 useita eri tyyppisi\xe4 arvoja, jos niiden tyypiksi m\xe4\xe4ritell\xe4\xe4n unioni tai leikkaus. Seuraavissa tapauksissa, kun arvot ovat joko merkkijonoja tai numeroita, p\xe4\xe4ttelee TypeScript taulukon tyypiksi automaattisesti unionin ",(0,t.jsx)(e.code,{children:"(string | number)[]"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"let values = [1, 2, 3, 'one', 'two', 'three'];  // (string | number)[]\nlet combo = [...faces, ...numbers];             // (string | number)[]\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Taulukoita k\xe4sitelt\xe4ess\xe4 TypeScript ei aina voi tiet\xe4\xe4, mink\xe4 tyyppinen arvo tietyst\xe4 indeksist\xe4 l\xf6ytyy, tai l\xf6ytyyk\xf6 siit\xe4 lainkaan arvoa. T\xe4ll\xf6in t\xf6rm\xe4\xe4t helposti tilanteeseen, jossa TypeScript p\xe4\xe4ttelee tyypiksi esimerkiksi ",(0,t.jsx)(e.code,{children:"undefined | string | number"}),"."]}),"\n",(0,t.jsxs)(e.p,{children:["Mik\xe4li koodissa ollaan varmoja, ett\xe4 arvo l\xf6ytyy ja ett\xe4 se on tietty\xe4 tyyppi\xe4, voit k\xe4ytt\xe4\xe4 ",(0,t.jsx)(e.code,{children:"as"}),"-avainsanaa, joka ohittaa TypeScriptin p\xe4\xe4ttelylogiikan:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"let values = [1, 2, 3, 'one', 'two', 'three'];\n\nlet first = all.at(0);              // p\xe4\xe4telty tyyppi on `first: (string | number)`\n\nlet second = all.at(1) as number;   // `as` ohittaa TypeScriptin tyyppien p\xe4\xe4ttelyn\n"})}),"\n",(0,t.jsx)(e.h3,{id:"pohdittavaa",children:"Pohdittavaa"}),"\n",(0,t.jsxs)(e.p,{children:["On eri asia, onko taulukkomuuttujan tyypiksi m\xe4\xe4ritetty esimerkiksi ",(0,t.jsx)(e.code,{children:"(string | number)[]"})," tai ",(0,t.jsx)(e.code,{children:"(string[] | number[])"}),". Pohdi tai kokeile omassa koodieditorissasi, miten n\xe4m\xe4 tyyppien unionit poikkeavat toisistaan."]}),"\n",(0,t.jsx)(e.h2,{id:"control-flow-analysis-cfa",children:"Control flow analysis (CFA)"}),"\n",(0,t.jsx)(e.p,{children:"Erityisesti unioneita k\xe4ytett\xe4ess\xe4 p\xe4\xe4dyt\xe4\xe4n usein tilanteisiin, joissa ohjelman loogiset polut eroavat k\xe4sitelt\xe4v\xe4n arvon tyypeist\xe4 riippuen."}),"\n",(0,t.jsx)(e.p,{children:"Seuraavat koodiesimerkit n\xe4ytt\xe4v\xe4t, miten TypeScript osaa tulkita JavaScriptin kontrollirakenteita rajatakseen eri arvojen mahdollisia tyyppej\xe4."}),"\n",(0,t.jsxs)(e.p,{children:["Kun koodissa on tehty esimerkiksi tarkastus ",(0,t.jsx)(e.code,{children:'if (typeof x !== "number")'}),", osaa TypeScript automaattisesti rajata ",(0,t.jsx)(e.code,{children:"x"}),":n"," mahdollisia tyyppej\xe4 seuraavilla riveill\xe4."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'const square = (x: number | undefined) => {\n    if (!x) {\n        throw new Error("Undefined");\n    }\n    return x * x; // TS tiet\xe4\xe4 t\xe4ss\xe4 vaiheessa, ett\xe4 arvon on oltava numero\n};\n\nconst square2 = (x: number | undefined) => {\n    if (typeof x !== "number") {\n        // typeof type guard\n        throw new Error("Not a number");\n    }\n    return x * x;\n};\n\nconst square3 = (x: number | undefined | string) => {\n    if (typeof x === "string") {\n        // typeof type guard\n        throw new Error("Not a number");\n    } else if (!x) {\n        throw new Error("Undefined");\n    }\n    return x * x;\n};\n\nconst square4 = (x: number | Date) => {\n    if (x instanceof Date) {\n        // Date is a class that can be initialized\n        throw new Error("Invalid type");\n    }\n    if (typeof x === "Date") {\n        // Error: This comparison appears to be unintentional because the types\n        //  \'"string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object"\n        //  | "function"\' and \'"Date"\' have no overlap.\n        throw new Error("Invalid type");\n    }\n    return x * x;\n};\n'})}),"\n",(0,t.jsx)(e.h3,{id:"sis\xe4kk\xe4inen-control-flow-analysis--esimerkki",children:"Sis\xe4kk\xe4inen Control flow analysis -esimerkki"}),"\n",(0,t.jsxs)(e.p,{children:["Artikkelissa ",(0,t.jsx)(e.a,{href:"https://retool.com/blog/typescript-control-flow-analysis-best-of/",children:"Get the best of TypeScript Control Flow Analysis (retool.com)"})," k\xe4sitell\xe4\xe4n laajemmin TypeScriptin tyyppianalyysi\xe4. Analyysi mahdollistaa mm. seuraavassa esimerkiss\xe4 esitetyn logiikan, jossa ",(0,t.jsx)(e.code,{children:"x"}),":n"," tyyppi saadaan rajattua kolmen tyypin unionista yhteen:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'const doSomething = (x: string | number | boolean) => {\n  const isString = typeof x === "string";\n  const isNumber = typeof x === "number";\n  const isStringOrNumber = isString || isNumber;\n\n  if (isStringOrNumber) {\n    x; // string | number\n    if (typeof x === "number") {\n      x; //number\n    }\n  } else {\n    x; //boolean\n  }\n};\n'})}),"\n",(0,t.jsx)(e.h2,{id:"bonus-lis\xe4\xe4-yksityiskohtia-tyyppien-rajauksesta",children:"Bonus: lis\xe4\xe4 yksityiskohtia tyyppien rajauksesta"}),"\n",(0,t.jsxs)(e.p,{children:["Voit tutustua t\xe4h\xe4n esimerkkii itsen\xe4isesti esimerkiksi koodieditorisi avulla. Tutustu aiheeseen my\xf6s ",(0,t.jsx)(e.a,{href:"https://www.typescriptlang.org/docs/handbook/2/narrowing.html",children:"TypeScriptin k\xe4sikirjassa"}),"."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'// JavaScript has an operator for determining if an object has a property with a name: the in operator.\n// TypeScript takes this into account as a way to narrow down potential types.\ntype Fish = { swim: () => void };\ntype Bird = { fly: () => void };\ntype Human = { swim?: () => void; fly?: () => void };\ntype Animal = Fish | Bird | Human;\n\nfunction move(animal: Animal) {\n    if ("swim" in animal) {\n        // Narrow down the type with JavaScript in operator\n        animal; // animal narrowed to Fish | Human\n\n        if ("fly" in animal) {\n            animal; // animal narrowed to Human\n\n        } else {\n            animal;\n            /* here it\'s still a Fish or Human, because TypeScript uses a concept called\n             *"control flow based type analysis" to determine the types of variables. This\n             * means that TypeScript can infer the type of a variable based on the control\n             * flow of the program, but it doesn\'t keep track of the types of variables\n             * within the different branches of the control flow. So, even though the type\n             * of animal was narrowed to Human in the previous block, TypeScript doesn\'t\n             * know that the type of animal is not Fish in the surrounding if-else block.*/\n        }\n    } else {\n        animal; // animal narrowed to Bird | Human\n    }\n    if (animal instanceof Fish) {\n        /* The instanceof operator is used to check the constructor of an object, but it\n         * doesn\'t work with discriminated unions. instanceof works by checking the prototype\n         * chain of an object, but since a union type can have multiple different prototypes,\n         * it can\'t determine the type correctly. */\n        animal;\n    }\n}\n\ntype Foo3 = {\n    x: number;\n};\ntype NumberType = Foo3["x"];\n\n'})}),"\n",(0,t.jsx)(e.h2,{id:"discriminated-unions",children:"Discriminated unions"}),"\n",(0,t.jsxs)(e.p,{children:["Unionin tyypeille m\xe4\xe4ritell\xe4\xe4n toisinaan yksitt\xe4inen muuttuja, jonka vakioarvon perusteella eri tyypit voidaan erottaa toisistaan. Esimerkiksi seuraavissa muotoja k\xe4sitteleviss\xe4 ",(0,t.jsx)(e.code,{children:"Rectangle"}),"- ja ",(0,t.jsx)(e.code,{children:"Circle"}),"-tyypeiss\xe4 on ",(0,t.jsx)(e.code,{children:"kind"}),"-muuttuja, jonka perusteella nelikulmiot ja ympyr\xe4t voidaan erottaa toisistaan ohjelmalogiikassa:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'interface Rectangle {\n    kind: "rectangle"; // discriminant property\n    width: number;\n    height: number;\n}\n\ninterface Circle {\n  kind: "circle"; // discriminant property\n  radius: number;\n}\n\ntype Shape = Rectangle | Circle; //discriminated union https://basarat.gitbook.io/typescript/type-system/discriminated-unions\n\nconst shape: Shape = { kind: "circle", radius: 5 };\nshape; // circle\n\nconst shape2: Shape = { kind: "rectangle", radius: 5 }; // not a valid type found from Shape union\n'})}),"\n",(0,t.jsxs)(e.p,{children:["Mik\xe4li olion ",(0,t.jsx)(e.code,{children:"kind"}),"-muuttujan arvo on ",(0,t.jsx)(e.code,{children:'"rectangle"'}),", osaa TypeScript huolehtia siit\xe4, ett\xe4 sill\xe4 on oltava juuri ",(0,t.jsx)(e.code,{children:"Rectangle"}),"-tyypiss\xe4 m\xe4\xe4ritellyt muuttujat eik\xe4 ",(0,t.jsx)(e.code,{children:"Circle"}),"-tyypin muuttujia."]}),"\n",(0,t.jsxs)(e.admonition,{title:"diskriminoivien tyyppien leikkaus",type:"info",children:[(0,t.jsx)(e.p,{children:"Mik\xe4li kahdessa eri tyypiss\xe4 on yhteinen attribuutti, jolla on eri tyypeiss\xe4 eri vakioarvot tai tyypit, ei niist\xe4 voida tehd\xe4 suoraan leikkausta. T\xe4ll\xf6in olisi ep\xe4selv\xe4\xe4, kumman leikkaukseen kuuluvan tyypin m\xe4\xe4rittely\xe4 tulisi k\xe4ytt\xe4\xe4."}),(0,t.jsxs)(e.p,{children:["Leikkaus on kuitenkin mahdollista hy\xf6dnyt\xe4m\xe4ll\xe4 ",(0,t.jsx)(e.code,{children:"Omit"}),"-aputyyppi\xe4, jonka avulla voidaan ilmaista mik\xe4 tahansa tyyppi ilman tietty\xe4 attribuuttia. ",(0,t.jsx)(e.a,{href:"/docs/tyypit/utility-types",children:"Omit-tyyppi\xe4 k\xe4sitell\xe4\xe4n tarkemmin materiaalin my\xf6hemm\xe4ss\xe4 osassa"}),", mutta k\xe4yt\xe4nn\xf6ss\xe4 voisimme sen avulla leikkauksen my\xf6s yll\xe4 esitetyist\xe4 ",(0,t.jsx)(e.code,{children:"Rectangle"}),"- ja ",(0,t.jsx)(e.code,{children:"Circle"}),"-tyypeist\xe4:"]}),(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'type RectangleCircleNever = Rectangle & Circle; // never union because of kind-property\ntype RectangleCircle = Omit<Rectangle, "kind"> &\n    Omit<Circle, "kind"> & { kind: "circlerect" }; // union with Omit utility type\n\nconst confusingShape: RectangleCircle = {\n    kind: "circlerect",\n    radius: 5,\n    width: 3,\n    height: 4,\n};\n'})})]}),"\n",(0,t.jsxs)(e.p,{children:["Lue lis\xe4\xe4 aiheesta ",(0,t.jsx)(e.a,{href:"https://www.typescriptlang.org/docs/handbook/2/objects.html",children:"TypeScriptin k\xe4sikirjasta"}),"."]})]})}function c(i={}){const{wrapper:e}={...(0,a.a)(),...i.components};return e?(0,t.jsx)(e,{...i,children:(0,t.jsx)(p,{...i})}):p(i)}},1151:(i,e,n)=>{n.d(e,{Z:()=>r,a:()=>o});var t=n(7294);const a={},s=t.createContext(a);function o(i){const e=t.useContext(s);return t.useMemo((function(){return"function"==typeof i?i(e):{...e,...i}}),[e,i])}function r(i){let e;return e=i.disableParentContext?"function"==typeof i.components?i.components(a):i.components||a:o(i.components),t.createElement(s.Provider,{value:e},i.children)}}}]);